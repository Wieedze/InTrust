export class MultiUploader {
    constructor(uploaders) {
        this.add = {
            file: (input) => this.executeMultiUpload((u) => u.add.file(input)),
            text: (content) => this.executeMultiUpload((u) => u.add.text(content)),
            json: (content) => this.executeMultiUpload((u) => u.add.json(content)),
            directory: (input) => this.executeMultiUpload((u) => u.add.directory(input)),
            url: (url) => this.executeMultiUpload((u) => u.add.url(url)),
            buffer: (content) => this.executeMultiUpload((u) => u.add.buffer(content)),
        };
        if (!uploaders.length) {
            throw new Error("At least one uploader is required");
        }
        this.uploaders = new Map(uploaders.map((uploader) => [uploader.id, uploader]));
    }
    get id() {
        return "multi";
    }
    async executeMultiUpload(operation) {
        const results = [];
        await Promise.all(Array.from(this.uploaders.entries()).map(async ([uploaderId, uploader]) => {
            const result = await operation(uploader);
            results.push([uploaderId, result]);
        }));
        const successResults = results
            .map(([_, result]) => result)
            .filter((r) => r.success);
        const successCount = successResults.length;
        const totalNodes = this.uploaders.size;
        const allNodesSucceeded = successCount === totalNodes;
        return {
            success: allNodesSucceeded,
            successCount,
            errorCount: totalNodes - successCount,
            totalNodes,
            allNodesSucceeded,
            cid: successResults[0]?.cid ?? "",
            results,
        };
    }
}
/**
 * Type guard to check if a result contains a files array
 * @param result - The upload result to check
 * @returns True if the result is a FileArrayResult
 */
function hasFiles(result) {
    return "files" in result;
}
